#/home-1/cnaechy1@jhu.edu/miniconda3/bin/python3.7
import os
import pandas as pd

configfile: "config.yaml"

''' Load from config '''
CHROM = config['CHROM']
INDIV = config['INDIV']
GROUP = config['GROUP']
NUM_SIM_READS = config['NUM_SIM_READS']
ALN_MAPQ_THRSD = config['ALN_MAPQ_THRSD']
POP_THRSD = config['POP_THRSD']
POP_STOCHASTIC = config['POP_STOCHASTIC']
POP_BLOCK_SIZE = config['POP_BLOCK_SIZE']
POP_USE_LD = config['POP_USE_LD']
DIR = config['DIR']
GENOME = config['GENOME']
VCF = config['VCF']
FAMILY = config['FAMILY']
SPOP = config['SPOP']
BCFTOOLS = config['BCFTOOLS']
MASON2 = config['MASON2']
PYTHON = config['PYTHON']
DIR_SCRIPTS = config['DIR_SCRIPTS']
THREADS = config['THREADS']
RAND_SEED = config['RAND_SEED']
''''''

PREFIX_VCF_F = os.path.join(DIR, CHROM + '_filtered')
PREFIX_MAJOR_F = os.path.join(DIR, 'major/' + CHROM + '_filtered_major')
PREFIX_MAJOR = os.path.join(DIR, 'major/' + CHROM + '_h37maj')
PREFIX_MAJOR_IDX = os.path.join(DIR, 'major/indexes/' + CHROM + '_h37maj')

DIR_PER_IDX = os.path.join(DIR, 'simulation/{INDIV}/indexes/')
PREFIX_PER = os.path.join(DIR, 'simulation/{INDIV}/' + CHROM + '-per')

DIR_POP_GENOME = os.path.join(DIR, 'pop_genome/')
POP_DIRNAME = 'thrds{0}_S{1}_block{2}_ld{3}'.format(POP_THRSD, POP_STOCHASTIC, POP_BLOCK_SIZE, POP_USE_LD)
POP_GENOME_SUFFIX = \
    CHROM + '_superpop_{GROUP}_thrds' + str(POP_THRSD) + \
    '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + \
    '_ld' + str(POP_USE_LD)
DIR_POP_GENOME_BLOCK = os.path.join(DIR_POP_GENOME, POP_DIRNAME + '/')
DIR_POP_GENOME_BLOCK_IDX = os.path.join(DIR_POP_GENOME_BLOCK, 'indexes/')

DIR_FIRST_PASS = os.path.join(DIR, 'experiments/{INDIV}/')
DIR_SECOND_PASS = os.path.join(DIR, 'experiments/{INDIV}/' + POP_DIRNAME)

DIR_RESULTS = os.path.join(DIR, 'results/')

IDX_ITEMS = ['1', '2', '3', '4', 'rev.1', 'rev.2']

def organize_accuracy(fn_input, fn_output):
    with open(fn_input, 'r') as f:
        list_tp = []
        list_all = []
        for line in f:
            if line.count('sensitivity_all') > 0:
                line = line.split()
                list_tp.append(int(line[3][1:]))
                list_all.append(int(line[5][:-1]))
    f_out = open(fn_output, 'w')
    f_out.write('{0}\n{1}\n{2}\n'.format(sum(list_tp), sum(list_all), sum(list_tp) / sum(list_all)))
    return

rule all:
    input:
        #: major allele ref index
        major = os.path.join(DIR, 'major.done'),
        #: personalized genomes
        per = os.path.join(DIR, 'personalization.done'),
        #: simulation profile
        sim = os.path.join(DIR, 'simulation.done'),
        #: indivs in populations
        spop = expand(os.path.join(DIR, '1KG_indivs/sample_superpop_{g}.txt'), g=GROUP),
        popg = expand(os.path.join(DIR, 'check_popgenome_{GROUP}.done'),
            GROUP = GROUP),
        #: first pass alignment
        fistpass = os.path.join(DIR, 'firstpass.done'),
        #: second pass alignment
        secondpass = os.path.join(DIR, 'secondpass.done'),
        #: accuracy
        acc = os.path.join(DIR, 'accuracy.done'),
        tsv = os.path.join(DIR_RESULTS, 'all.tsv')

rule filter_vcf:
    input:
        vcf = VCF
    output:
        vcf = PREFIX_VCF_F + '.vcf'
    shell:
        '{BCFTOOLS} view --threads {THREADS} -V mnps,other {input.vcf} > {output.vcf}'

'''
Rules for building major-allele genome
'''
rule build_major:
    input:
        genome = GENOME,
        vcf = PREFIX_VCF_F + '.vcf'
    output:
        vcf_major = PREFIX_MAJOR_F + '.vcf',
        vcf_major_gz = PREFIX_MAJOR_F + '.vcf.gz',
        vcf_major_gz_csi = PREFIX_MAJOR_F + '.vcf.gz.csi',
        out_genome = PREFIX_MAJOR + '.fa',
        out_var = PREFIX_MAJOR + '.var',
        out_vcf = PREFIX_MAJOR + '.vcf'
    shell:
        '{BCFTOOLS} view -O z --threads {THREADS} -q 0.5 {input.vcf} -e \'AF = 0.5\' -v snps,indels -m2 -M2 > '
        '{output.vcf_major_gz};'
        '{BCFTOOLS} index --threads {THREADS} {output.vcf_major_gz};'
        'bgzip -cd {output.vcf_major_gz} > {output.vcf_major};'
        '{PYTHON} {DIR_SCRIPTS}/update_genome.py '
        '    --ref {input.genome} --vcf {output.vcf_major} '
        '    --chrom {CHROM} --out-prefix {PREFIX_MAJOR} '
        '    --include-indels'

rule build_major_index:
    input:
        major = PREFIX_MAJOR + '.fa'
    output:
        PREFIX_MAJOR_IDX + '.1.bt2',
        PREFIX_MAJOR_IDX + '.2.bt2',
        PREFIX_MAJOR_IDX + '.3.bt2',
        PREFIX_MAJOR_IDX + '.4.bt2',
        PREFIX_MAJOR_IDX + '.rev.1.bt2',
        PREFIX_MAJOR_IDX + '.rev.2.bt2'
    shell:
        'bowtie2-build --threads {THREADS} {input.major} {PREFIX_MAJOR_IDX}'

rule check_major:
    input:
        expand(PREFIX_MAJOR_IDX + '.{idx_item}.bt2', idx_item = IDX_ITEMS)
    output:
        touch(temp(os.path.join(DIR, 'major.done')))

'''
Rules for building personalized genome
'''
rule build_per:
    input:
        genome = GENOME,
        vcf = PREFIX_VCF_F + '.vcf'
    output:
        hapA = PREFIX_PER + '_hapA.fa',
        hapB = PREFIX_PER + '_hapB.fa',
        var = PREFIX_PER + '.var'
    params:
        out_prefix = PREFIX_PER
    shell:
        '{PYTHON} {DIR_SCRIPTS}/update_genome.py '
        '    --ref {input.genome} --vcf {input.vcf} --name {wildcards.INDIV}'
        '    --chrom {CHROM} --out-prefix {params.out_prefix} '
        '    --include-indels'

rule build_per_index:
    input:
        perA = PREFIX_PER + '_hapA.fa',
        perB = PREFIX_PER + '_hapB.fa'
    output:
        DIR_PER_IDX + CHROM + '-per_hapA.1.bt2',
        DIR_PER_IDX + CHROM + '-per_hapA.2.bt2',
        DIR_PER_IDX + CHROM + '-per_hapA.3.bt2',
        DIR_PER_IDX + CHROM + '-per_hapA.4.bt2',
        DIR_PER_IDX + CHROM + '-per_hapA.rev.1.bt2',
        DIR_PER_IDX + CHROM + '-per_hapA.rev.2.bt2',
        DIR_PER_IDX + CHROM + '-per_hapB.1.bt2',
        DIR_PER_IDX + CHROM + '-per_hapB.2.bt2',
        DIR_PER_IDX + CHROM + '-per_hapB.3.bt2',
        DIR_PER_IDX + CHROM + '-per_hapB.4.bt2',
        DIR_PER_IDX + CHROM + '-per_hapB.rev.1.bt2',
        DIR_PER_IDX + CHROM + '-per_hapB.rev.2.bt2'
    params:
        prefix_idxA = DIR_PER_IDX + CHROM + '-per_hapA',
        prefix_idxB = DIR_PER_IDX + CHROM + '-per_hapB'
    shell:
        'bowtie2-build --threads {THREADS} {input.perA} {params.prefix_idxA};'
        'bowtie2-build --threads {THREADS} {input.perB} {params.prefix_idxB}'

rule check_per:
    input:
        expand(
            DIR_PER_IDX + CHROM + '-per_hapA.{idx_item}.bt2',
            idx_item = IDX_ITEMS,
            INDIV = INDIV
        ),
        expand(
            DIR_PER_IDX + CHROM + '-per_hapB.{idx_item}.bt2',
            idx_item = IDX_ITEMS,
            INDIV = INDIV
        )
    output:
        touch(temp(os.path.join(DIR, 'personalization.done')))

'''
Rules for simulate reads from personalized genomes
'''
rule simulate_reads:
    input:
        hapA = PREFIX_PER + '_hapA.fa',
        hapB = PREFIX_PER + '_hapB.fa'
    output:
        readsA1 = PREFIX_PER + '_hapA_1.fq',
        readsA2 = PREFIX_PER + '_hapA_2.fq',
        readsB1 = PREFIX_PER + '_hapB_1.fq',
        readsB2 = PREFIX_PER + '_hapB_2.fq',
        samA = PREFIX_PER + '_hapA.sam',
        samB = PREFIX_PER + '_hapB.sam'
    params:
        num = NUM_SIM_READS,
        prefix = PREFIX_PER
    shell:
        #: marcc specific
        'module load gcc/5.5.0;'
        '{MASON2} --num-threads {THREADS} -ir {input.hapA} -n {params.num} '
        '-o {params.prefix}_hapA_1.fq -or {params.prefix}_hapA_2.fq '
        '-oa {params.prefix}_hapA.sam --read-name-prefix "{params.prefix}_hapA_simulated.";'
        '{MASON2} --num-threads {THREADS} -ir {input.hapB} -n {params.num} '
        '-o {params.prefix}_hapB_1.fq -or {params.prefix}_hapB_2.fq '
        '-oa {params.prefix}_hapB.sam --read-name-prefix "{params.prefix}_hapB_simulated.";'

rule merge_simulated_reads:
    input:
        readsA1 = PREFIX_PER + '_hapA_1.fq',
        readsA2 = PREFIX_PER + '_hapA_2.fq',
        readsB1 = PREFIX_PER + '_hapB_1.fq',
        readsB2 = PREFIX_PER + '_hapB_2.fq',
    output:
        reads1 = PREFIX_PER + '_1.fq',
        reads2 = PREFIX_PER + '_2.fq'
    shell:
        'cat {input.readsA1} > {output.reads1};'
        'cat {input.readsA2} > {output.reads2};'
        'cat {input.readsB1} >> {output.reads1};'
        'cat {input.readsB2} >> {output.reads2};'

rule merge_simulated_sam:
    input:
        samA = PREFIX_PER + '_hapA.sam',
        samB = PREFIX_PER + '_hapB.sam'
    output:
        sam = temp(PREFIX_PER + '.sam'),
        sam1 = PREFIX_PER + '_1.sam',
        sam2 = PREFIX_PER + '_2.sam'
    shell:
        'grep ^@ {input.samA} > {output.sam};'
        #: get headers from B
        'grep ^@ {input.samB} | tail -n +2 >> {output.sam};'
        'grep -v ^@ {input.samA} >> {output.sam};'
        'grep -v ^@ {input.samB} >> {output.sam};'
        'samtools view -@ {THREADS} -h -f 64 {output.sam} -o {output.sam1};'
        'samtools view -@ {THREADS} -h -f 128 {output.sam} -o {output.sam2}'

rule check_simulation:
    input:
        expand(
            PREFIX_PER + '_{seg}.{type}',
            INDIV = INDIV,
            seg = ['1', '2'],
            type = ['fq', 'sam']
        )
    output:
        touch(temp(os.path.join(DIR, 'simulation.done')))

'''
Rules for building population genomes
'''
rule prepare_pop_indiv:
    output:
        expand(
            os.path.join(DIR, '1KG_indivs/sample_superpop_{GROUP}.txt'),
            GROUP = GROUP
        )
    params:
        prefix = os.path.join(DIR, '1KG_indivs/sample')
    shell:
        '{PYTHON} {DIR_SCRIPTS}/list_indiv_from_pop.py '
        '-p {FAMILY} -sp {SPOP} -op {params.prefix}'

rule build_pop_vcf:
    input:
        vcf = PREFIX_VCF_F + '.vcf',
        indiv_group = os.path.join(
            DIR,
            '1KG_indivs/sample_superpop_{GROUP}.txt'
        )
    output:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.vcf.gz')
    shell:
        '{BCFTOOLS} view --threads {THREADS} -S {input.indiv_group} '
        '--force-samples {input.vcf} -V mnps,other -m2 -M2 | '
        'bgzip -@ {THREADS} > {output.vcf_gz}'

rule get_pop_sample:
    input:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.vcf.gz')
    output:
        vcf_header = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.samples')
    shell:
        '{BCFTOOLS} view -h {input.vcf_gz} | tail -1 '
        '> {output.vcf_header}'

rule filter_pop_vcf:
    input:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.vcf.gz'),
        vcf_header = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.samples')
    output:
        vcf = os.path.join(
            DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}_t' + str(POP_THRSD) + '.vcf'
        )
    run:
        fn = list({input.vcf_header})[0]
        with open(fn, 'r') as f:
            for line in f:
                n = len(line.split()) - 9
                thrsd = int(n * 2 * float(POP_THRSD))
                filt = 'AC > {}'.format(thrsd)
                break
        shell('{BCFTOOLS} view --threads {THREADS} -i "{filt}" \
            -v snps,indels {input.vcf_gz} > {output.vcf};')

rule build_pop_genome:
    input:
        vcf = os.path.join(
            DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}_t' + str(POP_THRSD) + '.vcf'
        )
    output:
        os.path.join(
            DIR_POP_GENOME_BLOCK,
            CHROM + '_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.fa'
        ),
        os.path.join(
            DIR_POP_GENOME_BLOCK,
            CHROM + '_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.var'
        )
    params:
        prefix = os.path.join(
            DIR_POP_GENOME_BLOCK,
            CHROM + '_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD)
        )
    run:
        if POP_STOCHASTIC == 1 and POP_USE_LD == 1:
            shell('{PYTHON} {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels --stochastic -rs {RAND_SEED} \
                --block-size {POP_BLOCK_SIZE} --ld')
        elif POP_STOCHASTIC == 1:
            shell('{PYTHON} {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels --stochastic -rs {RAND_SEED} \
                --block-size {POP_BLOCK_SIZE}')
        else:
            shell('{PYTHON} {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels')

rule build_pop_genome_index:
    input:
        genome = DIR_POP_GENOME_BLOCK + POP_GENOME_SUFFIX + '.fa'
    output:
        DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.1.bt2',
        DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.2.bt2',
        DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.3.bt2',
        DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.4.bt2',
        DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.rev.1.bt2',
        DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.rev.2.bt2'
    params:
        prefix = DIR_POP_GENOME_BLOCK_IDX +
        POP_GENOME_SUFFIX
    shell:
        'bowtie2-build --threads {THREADS} {input.genome} {params.prefix};'

rule check_pop_genome:
    input:
        expand(
            DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.{IDX_ITEMS}.bt2',
            GROUP = GROUP, IDX_ITEMS = IDX_ITEMS
        )
    output:
        touch(temp(os.path.join(DIR, 'check_popgenome_{GROUP}.done')))

rule refflow_align_firstpass:
    input:
        reads1 = PREFIX_PER + '_1.fq',
        idx = expand(PREFIX_MAJOR_IDX + '.{IDX_ITEMS}.bt2', IDX_ITEMS = IDX_ITEMS)
    params:
        index = PREFIX_MAJOR_IDX
    output:
        sam = os.path.join(DIR_FIRST_PASS, CHROM + '-h37maj.sam')
    shell:
        'bowtie2 --threads {THREADS} -x {params.index} -U {input.reads1} -S {output.sam}'

rule refflow_separate_fistpass_results:
    input:
        sam = os.path.join(DIR_FIRST_PASS, CHROM + '-h37maj.sam')
    output:
        highq = os.path.join(DIR_FIRST_PASS, CHROM + 
            '-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '.sam'),
        lowq = os.path.join(DIR_FIRST_PASS, CHROM + 
            '-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.sam'),
        lowq_reads = os.path.join(DIR_FIRST_PASS, CHROM +
            '-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq')
    shell:
        'awk -v var="{ALN_MAPQ_THRSD}" \
        \'{{ if ($5 >= var || $1 ~ /^@/) {{ print }} }}\' {input.sam} > \
        {output.highq};'
        'awk -v var={ALN_MAPQ_THRSD} \
        \'{{ if ($5 < var || $1 ~ /^@/) {{ print }} }}\' {input.sam} > \
        {output.lowq};'
        'samtools fastq {output.lowq} > {output.lowq_reads}'

rule check_firstpass:
    input:
        sam = expand(
            os.path.join(DIR_FIRST_PASS, CHROM + '-h37maj.sam'),
            INDIV = INDIV),
        highq = expand(
            os.path.join(DIR_FIRST_PASS, CHROM + 
            '-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '.sam'),
            INDIV = INDIV),
        lowq_reads = expand(
            os.path.join(DIR_FIRST_PASS, CHROM +
            '-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq'),
            INDIV = INDIV)
    output:
        touch(temp(os.path.join(DIR, 'firstpass.done')))

rule refflow_align_secondpass:
    input:
        reads = os.path.join(DIR_FIRST_PASS, CHROM +
            '-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq'),
        idx1 = DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.1.bt2',
        idx2 = DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.2.bt2',
        idx3 = DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.3.bt2',
        idx4 = DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.4.bt2',
        idx5 = DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.rev.1.bt2',
        idx6 = DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX + '.rev.2.bt2'
    params:
        index = DIR_POP_GENOME_BLOCK_IDX + POP_GENOME_SUFFIX
    output:
        sam = os.path.join(DIR_SECOND_PASS, CHROM + '-h37maj-{GROUP}.sam')
    shell:
        'bowtie2 --threads {THREADS} -x {params.index} -U {input.reads} -S {output.sam};'

rule refflow_merge_secondpass:
    input:
        sam = expand(
            os.path.join(DIR_SECOND_PASS, CHROM + '-h37maj-{GROUP}.sam'),
            INDIV = INDIV, GROUP = GROUP)
    output:
        path = os.path.join(DIR_SECOND_PASS, CHROM + '-h37maj-secondpass.paths'),
        id = os.path.join(DIR_SECOND_PASS, CHROM + '-h37maj-secondpass.ids'),
        merge_path = os.path.join(DIR_SECOND_PASS, CHROM + '-h37maj-secondpass-merged.paths')
    run:
        indiv = wildcards.INDIV
        dir_2p = os.path.join(DIR, 'experiments/' + indiv + '/' + POP_DIRNAME)
        for g in GROUP:
            fn = os.path.join(dir_2p, CHROM + '-h37maj-' + g + '.sam')
            shell('ls {fn} >> {output.path};')
            shell('echo {g} >> {output.id}')
        shell('{PYTHON} {DIR_SCRIPTS}/merge_sam.py \
            -ns {output.path} -ids {output.id} \
            -rs 0 -l {output.merge_path}')
        
rule check_secondpass:
    input:
        sam = expand(
            os.path.join(DIR_SECOND_PASS, CHROM + '-h37maj-secondpass.paths'),
            INDIV = INDIV, GROUP = GROUP
        ),
        merge = expand(
            os.path.join(DIR_SECOND_PASS, CHROM + '-h37maj-secondpass-merged.paths'),
            INDIV = INDIV, GROUP = GROUP
        )
    output:
        touch(temp(os.path.join(DIR, 'secondpass.done')))

rule personalize_align:
    input:
        reads1 = PREFIX_PER + '_1.fq',
        idxA = expand(DIR_PER_IDX + CHROM + '-per_hapA.{IDX_ITEMS}.bt2', IDX_ITEMS = IDX_ITEMS, INDIV = INDIV),
        idxB = expand(DIR_PER_IDX + CHROM + '-per_hapB.{IDX_ITEMS}.bt2', IDX_ITEMS = IDX_ITEMS, INDIV = INDIV)
    params:
        indexA = DIR_PER_IDX + CHROM + '-per_hapA',
        indexB = DIR_PER_IDX + CHROM + '-per_hapB'
    output:
        samA = DIR_FIRST_PASS + CHROM + '-per_hapA.sam',
        samB = DIR_FIRST_PASS + CHROM + '-per_hapB.sam'
    shell:
        'bowtie2 --threads {THREADS} -x {params.indexA} -U {input.reads1} -S {output.samA};'
        'bowtie2 --threads {THREADS} -x {params.indexB} -U {input.reads1} -S {output.samB}'

rule personalize_merge_and_calc_accuracy:
    input:
        samA = DIR_FIRST_PASS + CHROM + '-per_hapA.sam',
        samB = DIR_FIRST_PASS + CHROM + '-per_hapB.sam',
        gold = PREFIX_PER + '_1.sam',
        var_reads = PREFIX_PER + '.var',
    output:
        merge_path = os.path.join(DIR_FIRST_PASS, CHROM + '-per-merged.paths'),
        acc_log = os.path.join(DIR_FIRST_PASS, CHROM + '-per.acc_log'),
        acc = os.path.join(DIR_RESULTS, '{INDIV}-' + CHROM + '-per.acc')
    run:
        shell('{PYTHON} {DIR_SCRIPTS}/merge_sam.py \
            -n1 {input.samA} -id1 hapA \
            -n2 {input.samB} -id2 hapB \
            -rs 0 -l {output.merge_path};')
        with open(output.merge_path, 'r') as f:
            for line in f:
                fn = line.rstrip()
                shell('{PYTHON} -O {DIR_SCRIPTS}/analyze_diploid_indels.py \
                -c {CHROM} -g {input.gold} -p 2 -vr {input.var_reads} \
                -vs {input.var_reads} -n {fn} >> {output.acc_log}')
        organize_accuracy(output.acc_log, output.acc)

rule major_calc_accuracy:
    input:
        sam = os.path.join(DIR_FIRST_PASS, CHROM + '-h37maj.sam'),
        var_genome = PREFIX_MAJOR + '.var',
        gold = PREFIX_PER + '_1.sam',
        var_reads = PREFIX_PER + '.var',
    output:
        acc_log = os.path.join(DIR_FIRST_PASS, CHROM + '-h37maj.acc_log'),
        acc = os.path.join(DIR_RESULTS, '{INDIV}-' + CHROM + '-h37maj.acc')
    run:
        shell('{PYTHON} -O {DIR_SCRIPTS}/analyze_diploid_indels.py \
        -c {CHROM} -g {input.gold} -p 0 -vr {input.var_reads} \
        -vs {input.var_genome} -n {input.sam} > {output.acc_log};')
        organize_accuracy(output.acc_log, output.acc)

rule check_major_and_per_accuracy:
    input:
        expand(
            os.path.join(DIR_RESULTS, '{INDIV}-' + CHROM + '-h37maj.acc'),
            INDIV = INDIV),
        expand(
            os.path.join(DIR_RESULTS, '{INDIV}-' + CHROM + '-per.acc'),
            INDIV = INDIV)
    output:
        touch(temp(os.path.join(DIR, '{INDIV}_onepass_acc.done')))

rule calc_refflow_accuracy:
    input:
        gold = PREFIX_PER + '_1.sam',
        var_reads = PREFIX_PER + '.var',
        first_sam = os.path.join(DIR_FIRST_PASS, CHROM + 
            '-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '.sam'),
        first_var_genome = PREFIX_MAJOR + '.var',
        second_sam_path = os.path.join(DIR_SECOND_PASS, 
            CHROM + '-h37maj-secondpass-merged.paths'),
        second_group = os.path.join(DIR_SECOND_PASS, 
            CHROM + '-h37maj-secondpass.ids'),
        second_var_genome = expand(
            os.path.join(
            DIR_POP_GENOME_BLOCK,
            CHROM + '_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.var'),
            INDIV = INDIV, GROUP = GROUP
        )
    output:
        acc_log = os.path.join(DIR_FIRST_PASS, CHROM + '-' + POP_DIRNAME + '.acc_log')
    run:
        if os.path.exists(output.acc_log):
            shell('rm {output.acc_log};')
        shell(
            '{PYTHON} -O {DIR_SCRIPTS}/analyze_diploid_indels.py \
            -c {CHROM} -g {input.gold} -p 0 -vr {input.var_reads} \
            -vs {input.first_var_genome} -n {input.first_sam} >> \
            {output.acc_log};')
        list_group = []
        with open(input.second_group) as f:
            for line in f:
                list_group.append(line.rstrip())
        list_fn = []
        with open(input.second_sam_path) as f:
            for line in f:
                list_fn.append(line.rstrip())
        for i, fn in enumerate(list_fn):
            second_var_genome = os.path.join(
                DIR_POP_GENOME_BLOCK,
                CHROM + '_superpop_' + list_group[i] + '_thrds' + str(POP_THRSD) +
                '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
                '_ld' + str(POP_USE_LD) + '.var')
            shell('{PYTHON} -O {DIR_SCRIPTS}/analyze_diploid_indels.py \
            -c {CHROM} -g {input.gold} -p 0 -vr {input.var_reads} \
            -vs {second_var_genome} -n {fn} >> \
            {output.acc_log};')

rule sum_refflow_accuracy:
    input:
        acc_log = os.path.join(DIR_FIRST_PASS, CHROM + '-' + POP_DIRNAME + '.acc_log')
    output:
        acc = os.path.join(DIR_RESULTS,
            '{INDIV}-' + CHROM + '-h37maj-' + POP_DIRNAME + '.acc')
    run:
        organize_accuracy(input.acc_log, output.acc)

rule write_as_tsv:
    input:
        acc_log = expand(os.path.join(DIR_RESULTS,
            '{INDIV}-' + CHROM + '-h37maj-' + POP_DIRNAME + '.acc'),
            INDIV = INDIV),
        check_onepass_acc = expand(os.path.join(DIR, '{INDIV}_onepass_acc.done'), INDIV = INDIV)
    output:
        tsv = os.path.join(DIR_RESULTS, 'all.tsv'),
        check = touch(temp(os.path.join(DIR, 'accuracy.done')))
    run:
        df = pd.DataFrame()
        list_fn = os.listdir(DIR_RESULTS)
        list_fn = [os.path.join(DIR_RESULTS, fn) for fn in list_fn]
        list_exp = []
        list_tp = []
        list_all = []
        list_sensitivity = []
        for fn in list_fn:
            if fn.endswith('.acc'):
                with open(fn, 'r') as f:
                    for i, line in enumerate(f):
                        if i == 0:
                            list_tp.append(int(line))
                        elif i == 1:
                            list_all.append(int(line))
                fn = fn[: fn.rfind('.acc')]
                list_exp.append(os.path.basename(fn))
        df['Experiments'] = list_exp
        df['True Positive'] = list_tp
        df['Num Reads'] = list_all
        df.to_csv(output.tsv, sep='\t', index=None)
