import os

CHROM = '21'
INDIV = ['NA12878']
GROUP = ['EUR', 'AMR', 'EAS', 'SAS', 'AFR']
NUM_SIM_READS = 1000000

DIR = '/net/langmead-bigmem-ib/storage2/naechyun/refflow/chr21/pipeline'
GENOME = '/net/langmead-bigmem-ib.bluecrab.cluster/storage/naechyun/relaxation/chr21/chr21.fa'
VCF = '/net/langmead-bigmem-ib.bluecrab.cluster/storage/naechyun/relaxation/chr21/21.vcf'
FAMILY = '/net/langmead-bigmem-ib.bluecrab.cluster/storage/naechyun/relaxation/20130606_g1k.ped'
SPOP = '/net/langmead-bigmem-ib.bluecrab.cluster/storage/naechyun/relaxation/1kg.superpopulation'

BCFTOOLS = '/home-1/cnaechy1@jhu.edu/bin/bcftools'
MASON2 = '/net/langmead-bigmem-ib.bluecrab.cluster/storage/naechyun/software/mason_simulator'
DIR_SCRIPTS = '/net/langmead-bigmem-ib/storage2/naechyun/genome_relaxation/scripts'

PREFIX_VCF_F = os.path.join(DIR, CHROM + '_filtered')
PREFIX_MAJOR_F = os.path.join(DIR, 'major/' + CHROM + '_filtered_major')
PREFIX_MAJOR = os.path.join(DIR, 'major/' + CHROM + '_h37maj')
PREFIX_MAJOR_IDX = os.path.join(DIR, 'major/indexes/' + CHROM + '_h37maj')

DIR_PER_IDX = os.path.join(DIR, '{INDIV}/indexes/')
PREFIX_PER = os.path.join(DIR, '{INDIV}/per')

POP_THRSD = 0
POP_STOCHASTIC = 1
POP_BLOCK_SIZE = 5000
POP_USE_LD = 1
DIR_POP_GENOME = os.path.join(DIR, 'pop_genome/')
POP_DIRNAME = 'thrds{0}_S{1}_block{2}_ld{3}'.format(POP_THRSD, POP_STOCHASTIC, POP_BLOCK_SIZE, POP_USE_LD)
DIR_POP_GENOME_BLOCK = os.path.join(DIR_POP_GENOME, POP_DIRNAME + '/')

IDX_ITEMS = ['1', '2', '3', '4', 'rev.1', 'rev.2']

THREADS=16
RAND_SEED = 0

rule all:
    input:
        #: major allele ref index
        major = os.path.join(DIR, 'major.done'),
        #: personalized genomes
        per = os.path.join(DIR, 'personalization.done'),
        #: simulation profile
        sim = os.path.join(DIR, 'simulation.done'),
        #: indivs in populations
        spop = expand(os.path.join(DIR, '1KG_indivs/sample_superpop_{g}.txt'), g=GROUP),
        spop_vcf_gz = expand(
            os.path.join(
                DIR_POP_GENOME,
                CHROM + '_superpop_{GROUP}.vcf.gz'),
            GROUP = GROUP),
        popg = expand(
            os.path.join(DIR, 'pop_genome_{GROUP}.ing'),
            GROUP = GROUP)
    #shell:
    #    'rm {input.major} {input.per} {input.sim};'
    #    'rm {input.popg}'

rule filter_vcf:
    input:
        vcf = VCF
    output:
        vcf = PREFIX_VCF_F + '.vcf.gz'
    shell:
        '{BCFTOOLS} view --threads THREADS -V mnps,other {input.vcf} > {output.vcf}'

'''
Rules for building major-allele genome
'''
rule build_major:
    input:
        genome = GENOME,
        vcf = PREFIX_VCF_F + '.vcf.gz'
    output:
        vcf_major = PREFIX_MAJOR_F + '.vcf',
        vcf_major_gz = PREFIX_MAJOR_F + '.vcf.gz',
        vcf_major_gz_csi = PREFIX_MAJOR_F + '.vcf.gz.csi',
        out_genome = PREFIX_MAJOR + '.fa',
        out_var = PREFIX_MAJOR + '.var',
        out_vcf = PREFIX_MAJOR + '.vcf'
    shell:
        '{BCFTOOLS} view -O v --threads THREADS -q 0.5 {input.vcf} -e \'AF = 0.5\' -v snps,indels | '
        'vcftools --vcf - --min-alleles 2 --max-alleles 2 --recode-INFO-all --recode --stdout | '
        'bgzip -@ THREADS > {output.vcf_major_gz};'
        '{BCFTOOLS} index --threads THREADS {output.vcf_major_gz};'
        'bgzip -cd {output.vcf_major_gz} > {output.vcf_major};'
        'python {DIR_SCRIPTS}/update_genome.py '
        '    --ref {input.genome} --vcf {output.vcf_major} '
        '    --chrom {CHROM} --out-prefix {PREFIX_MAJOR} '
        '    --include-indels'

rule build_major_index:
    input:
        major = PREFIX_MAJOR + '.fa'
    output:
        PREFIX_MAJOR_IDX + '.{IDX_ITEMS}.bt2'
    shell:
        'bowtie2-build --threads THREADS {input.major} {PREFIX_MAJOR_IDX}'

rule check_major:
    input:
        expand(PREFIX_MAJOR_IDX + '.{idx_item}.bt2', idx_item = IDX_ITEMS)
    output:
        touch(temp(os.path.join(DIR, 'major.done')))

'''
Rules for building personalized genome
'''
rule build_per:
    input:
        genome = GENOME,
        vcf = PREFIX_VCF_F + '.vcf.gz'
    output:
        hapA = PREFIX_PER + '_hapA.fa',
        hapB = PREFIX_PER + '_hapB.fa'
    params:
        out_prefix = PREFIX_PER,
    shell:
        'python {DIR_SCRIPTS}/update_genome.py '
        '    --ref {input.genome} --vcf {input.vcf} --name {INDIV}'
        '    --chrom {CHROM} --out-prefix {params.out_prefix} '
        '    --include-indels'

rule build_per_index:
    input:
        perA = PREFIX_PER + '_hapA.fa',
        perB = PREFIX_PER + '_hapB.fa'
    output:
        DIR_PER_IDX + 'per_hapA.{IDX_ITEMS}.bt2',
        DIR_PER_IDX + 'per_hapB.{IDX_ITEMS}.bt2'
    params:
        prefix_idxA = DIR_PER_IDX + 'per_hapA',
        prefix_idxB = DIR_PER_IDX + 'per_hapB'
    shell:
        'bowtie2-build --threads THREADS {input.perA} {params.prefix_idxA};'
        'bowtie2-build --threads THREADS {input.perB} {params.prefix_idxB}'

rule check_per:
    input:
        expand(
            os.path.join(DIR, '{indiv}/indexes/per_hapA.{idx_item}.bt2'),
            idx_item = IDX_ITEMS,
            indiv = INDIV
        ),
        expand(
            os.path.join(DIR, '{indiv}/indexes/per_hapB.{idx_item}.bt2'),
            idx_item = IDX_ITEMS,
            indiv=INDIV
        )
    output:
        touch(temp(os.path.join(DIR, 'personalization.done')))

'''
Rules for simulate reads from personalized genomes
'''
rule simulate_reads:
    input:
        hapA = PREFIX_PER + '_hapA.fa',
        hapB = PREFIX_PER + '_hapB.fa'
    output:
        readsA1 = PREFIX_PER + '_hapA_1.fq',
        readsA2 = PREFIX_PER + '_hapA_2.fq',
        readsB1 = PREFIX_PER + '_hapB_1.fq',
        readsB2 = PREFIX_PER + '_hapB_2.fq',
        samA = PREFIX_PER + '_hapA.sam',
        samB = PREFIX_PER + '_hapB.sam'
    params:
        num = NUM_SIM_READS,
        prefix = PREFIX_PER
    shell:
        #: marcc specific
        'module load gcc/5.5.0;'
        '{MASON2} --num-threads THREADS -ir {input.hapA} -n {params.num} '
        '-o {params.prefix}_hapA_1.fq -or {params.prefix}_hapA_2.fq '
        '-oa {params.prefix}_hapA.sam --read-name-prefix "{params.prefix}_hapA_simulated.";'
        '{MASON2} --num-threads THREADS -ir {input.hapB} -n {params.num} '
        '-o {params.prefix}_hapB_1.fq -or {params.prefix}_hapB_2.fq '
        '-oa {params.prefix}_hapB.sam --read-name-prefix "{params.prefix}_hapB_simulated.";'

rule merge_simulated_reads:
    input:
        readsA1 = PREFIX_PER + '_hapA_1.fq',
        readsA2 = PREFIX_PER + '_hapA_2.fq',
        readsB1 = PREFIX_PER + '_hapB_1.fq',
        readsB2 = PREFIX_PER + '_hapB_2.fq',
    output:
        reads1 = PREFIX_PER + '_1.fq',
        reads2 = PREFIX_PER + '_2.fq'
    shell:
        'cat {input.readsA1} > {output.reads1};'
        'cat {input.readsA2} > {output.reads2};'
        'cat {input.readsB1} >> {output.reads1};'
        'cat {input.readsB2} >> {output.reads2};'

rule merge_simulated_sam:
    input:
        samA = PREFIX_PER + '_hapA.sam',
        samB = PREFIX_PER + '_hapB.sam'
    output:
        sam = temp(PREFIX_PER + '.sam'),
        sam1 = PREFIX_PER + '_1.sam',
        sam2 = PREFIX_PER + '_2.sam'
    shell:
        'grep ^@ {input.samA} > {output.sam};'
        #: get headers from B
        'grep ^@ {input.samB} | tail -n +2 >> {output.sam};'
        'grep -v ^@ {input.samA} >> {output.sam};'
        'grep -v ^@ {input.samB} >> {output.sam};'
        'samtools view -@ THREADS -h -f 64 {output.sam} -o {output.sam1};'
        'samtools view -@ THREADS -h -f 128 {output.sam} -o {output.sam2}'

rule check_simulation:
    input:
        expand(
            os.path.join(DIR, '{indiv}/per_{hap}.{type}'),
            indiv = INDIV,
            hap = ['1', '2'],
            type = ['fq', 'sam']
        )
    output:
        touch(temp(os.path.join(DIR, 'simulation.done')))

'''
Rules for building population genomes
'''
rule prepare_pop_indiv:
    output:
        os.path.join(DIR, '1KG_indivs/sample_superpop_{GROUP}.txt')
    params:
        prefix = os.path.join(DIR, '1KG_indivs/sample')
    shell:
        'python {DIR_SCRIPTS}/list_indiv_from_pop.py '
        '-p {FAMILY} -sp {SPOP} -op {params.prefix}'

rule build_pop_vcf:
    input:
        vcf = PREFIX_VCF_F + '.vcf.gz',
        indiv_group = os.path.join(
            DIR,
            '1KG_indivs/sample_superpop_{GROUP}.txt'
        )
    output:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.vcf.gz')
    shell:
        '{BCFTOOLS} view --threads THREADS -S {input.indiv_group} '
        '--force-samples {input.vcf} -V mnps,other -m2 -M2 | '
        'bgzip -@ THREADS > {output.vcf_gz}'

       # '{BCFTOOLS} view --threads THREADS -S {input.indiv_group} '
       # '--force-samples {input.vcf} -V mnps,other | '
       # 'vcftools --vcf - --min-alleles 2 --max-alleles 2 '
       # '--recode-INFO-all --recode --stdout | '
       # 'bgzip -@ THREADS > {output.vcf_gz}'

rule get_pop_sample:
    input:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.vcf.gz')
    output:
        vcf_header = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.samples')
    shell:
        '{BCFTOOLS} view -h {input.vcf_gz} | tail -1 '
        '> {output.vcf_header}'

rule filter_pop_vcf:
    input:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.vcf.gz'),
        vcf_header = os.path.join(DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}.samples')
    output:
        vcf = os.path.join(
            DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}_t' + str(POP_THRSD) + '.vcf'
        )
    run:
        fn = list({input.vcf_header})[0]
        with open(fn, 'r') as f:
            for line in f:
                n = len(line.split()) - 9
                thrsd = int(n * 2 * float(POP_THRSD))
                filt = 'AC > {}'.format(thrsd)
                break
        shell('{BCFTOOLS} view --threads THREADS -i "{filt}" \
            -v snps,indels {input.vcf_gz} > {output.vcf};')

rule build_pop_genome:
    input:
        vcf = os.path.join(
            DIR_POP_GENOME,
            CHROM + '_superpop_{GROUP}_t' + str(POP_THRSD) + '.vcf'
        )
    output:
        vcf = os.path.join(
            DIR_POP_GENOME_BLOCK,
            CHROM + '_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.vcf'
        )
    params:
        prefix = os.path.join(
            DIR_POP_GENOME_BLOCK,
            CHROM + '_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD)
        )
    run:
        if POP_STOCHASTIC == 1 and POP_USE_LD == 1:
            shell('python3.7 {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels --stochastic -rs {RAND_SEED} \
                --block-size {POP_BLOCK_SIZE} --ld')
        elif POP_STOCHASTIC == 1:
            shell('python3.7 {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels --stochastic -rs {RAND_SEED} \
                --block-size {POP_BLOCK_SIZE}')
        else:
            shell('python3.7 {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels')

rule check_pop_genome:
    input:
        expand(os.path.join(
            DIR_POP_GENOME_BLOCK,
            CHROM + '_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.vcf'
        ), GROUP = GROUP)
    output:
        touch(temp(os.path.join(DIR, 'pop_genome_{GROUP}.ing')))

# rule merge_two_pass:
#     input:
# 
# rule align_second_pass:
#     input:
# 
# rule first_pass:
#     input:
#     params:
#         index = INDEX
#     output:
#     shell:
#         "bowtie2 --threads THREADS -x {params.index} -U "````
