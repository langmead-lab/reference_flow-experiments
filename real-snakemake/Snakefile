#/home-1/cnaechy1@jhu.edu/miniconda3/bin/python3.7
import os
import pandas as pd

configfile: "config.yaml"

''' Load from config '''
CHROM = config['CHROM']
INDIV = config['INDIV']
READS1 = config['READS1']
GROUP = config['GROUP']
# NUM_SIM_READS = config['NUM_SIM_READS']
ALN_MAPQ_THRSD = config['ALN_MAPQ_THRSD']
POP_THRSD = config['POP_THRSD']
POP_STOCHASTIC = config['POP_STOCHASTIC']
POP_BLOCK_SIZE = config['POP_BLOCK_SIZE']
POP_USE_LD = config['POP_USE_LD']
DIR = config['DIR']
GENOME = config['GENOME']
# VCF = config['VCF']
DIR_VCF = config['DIR_VCF']

FAMILY = config['FAMILY']
SPOP = config['SPOP']
BCFTOOLS = config['BCFTOOLS']
SAMTOOLS = config['SAMTOOLS']
MASON2 = config['MASON2']
LIFTOVER = config['LIFTOVER']
PYTHON = config['PYTHON']
DIR_SCRIPTS = config['DIR_SCRIPTS']
THREADS = config['THREADS']
RAND_SEED = config['RAND_SEED']
MAX_NUM_READS_FOR_MERGING = config['MAX_NUM_READS_FOR_MERGING']
''''''

PREFIX_VCF_F = os.path.join(DIR, '{CHROM}_filtered')
PREFIX_MAJOR_F = os.path.join(DIR, 'major/{CHROM}_filtered_major')
PREFIX_MAJOR = os.path.join(DIR, 'major/{CHROM}_h37maj')
DIR_MAJOR = os.path.join(DIR, 'major')

DIR_FIRST_PASS = os.path.join(DIR, 'experiments/' + INDIV + '/')

DIR_POP_GENOME = os.path.join(DIR, 'pop_genome/')
POP_DIRNAME = 'thrds{0}_S{1}_block{2}_ld{3}'.format(POP_THRSD, POP_STOCHASTIC, POP_BLOCK_SIZE, POP_USE_LD)
POP_GENOME_SUFFIX = \
    '{CHROM}_superpop_{GROUP}_thrds' + str(POP_THRSD) + \
    '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + \
    '_ld' + str(POP_USE_LD)
WG_POP_GENOME_SUFFIX = \
    'wg_superpop_{GROUP}_thrds' + str(POP_THRSD) + \
    '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + \
    '_ld' + str(POP_USE_LD)
DIR_POP_GENOME_BLOCK = os.path.join(DIR_POP_GENOME, POP_DIRNAME + '/')
DIR_POP_GENOME_BLOCK_IDX = os.path.join(DIR_POP_GENOME_BLOCK, 'indexes/')

DIR_FIRST_PASS = os.path.join(DIR, 'experiments/{INDIV}/')
DIR_SECOND_PASS = os.path.join(DIR, 'experiments/{INDIV}/' + POP_DIRNAME)
PREFIX_SECOND_PASS = os.path.join(DIR_SECOND_PASS, 'wg-h37maj-' + ALN_MAPQ_THRSD + '-{GROUP}-' + POP_DIRNAME)

IDX_ITEMS = ['1', '2', '3', '4', 'rev.1', 'rev.2']

rule all:
    input:
        filtered_vcf = expand(PREFIX_VCF_F + '.vcf', CHROM = CHROM),
        major_idx = expand(
            os.path.join(DIR,
            'major/indexes/wg_h37maj.{idx}.bt2'), idx = IDX_ITEMS),
        major_sam = expand(os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam'), INDIV = INDIV),
        grch37_sam = expand(os.path.join(DIR_FIRST_PASS, 'wg-GRCh37.sam'), INDIV = INDIV),
        check_popg = expand(os.path.join(DIR, 'check_popgenome_{GROUP}.done'),
            GROUP = GROUP),
        secondpass = os.path.join(DIR, 'secondpass.done'),
        # secondpass_tmptmp = dynamic(os.path.join(DIR, 'secondpass_useless.done')),
        # secondpass_tmp = dynamic(os.path.join(DIR, 'secondpass_useless.done_{fq_id}'))
        het_no_overlaps = expand(os.path.join(DIR, 'wg_{INDIV}_het_no_overlaps.vcf'), INDIV = INDIV),
        lifted_major = expand(os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover.sam'), INDIV = INDIV)

rule filter_vcf:
    input:
        vcf = os.path.join(DIR_VCF, '{CHROM}.vcf.gz')
    output:
        vcf = PREFIX_VCF_F + '.vcf'
    shell:
        '{BCFTOOLS} view --threads {THREADS} -V mnps,other {input.vcf} > {output.vcf}'

rule build_major:
    input:
        genome = GENOME,
        vcf = PREFIX_VCF_F + '.vcf'
    output:
        vcf_major = PREFIX_MAJOR_F + '.vcf',
        vcf_major_gz = PREFIX_MAJOR_F + '.vcf.gz',
        vcf_major_gz_csi = PREFIX_MAJOR_F + '.vcf.gz.csi',
        out_genome = PREFIX_MAJOR + '.fa',
        out_var = PREFIX_MAJOR + '.var',
        out_vcf = PREFIX_MAJOR + '.vcf'
    params:
        chrom_genome = os.path.join(DIR, '{CHROM}.fa'),
        out_prefix = os.path.join(DIR, 'major/{CHROM}_h37maj')
    shell:
        '{BCFTOOLS} view -O z --threads {THREADS} -q 0.5 {input.vcf} -e \'AF = 0.5\' -v snps,indels -m2 -M2 > '
        '{output.vcf_major_gz};'
        '{BCFTOOLS} index --threads {THREADS} {output.vcf_major_gz};'
        'bgzip -cd {output.vcf_major_gz} > {output.vcf_major};'
        '{SAMTOOLS} faidx {input.genome} {wildcards.CHROM} > {params.chrom_genome};'
        '{PYTHON} {DIR_SCRIPTS}/update_genome.py '
        '    --ref {params.chrom_genome} --vcf {output.vcf_major} '
        '    --chrom {wildcards.CHROM} --out-prefix {params.out_prefix} '
        '    --include-indels'

rule merge_major:
    input:
        expand(PREFIX_MAJOR + '.fa', CHROM = CHROM)
    output:
        os.path.join(DIR, 'major/wg_h37maj.fa')
    shell:
        'cat {input} >> {output}'

rule build_major_index:
    input:
        os.path.join(DIR, 'major/wg_h37maj.fa')
    output:
        expand(
            os.path.join(DIR, 'major/indexes/wg_h37maj.{idx}.bt2'),
            idx = IDX_ITEMS)
        # PREFIX_MAJOR_IDX + '.1.bt2',
        # PREFIX_MAJOR_IDX + '.2.bt2',
        # PREFIX_MAJOR_IDX + '.3.bt2',
        # PREFIX_MAJOR_IDX + '.4.bt2',
        # PREFIX_MAJOR_IDX + '.rev.1.bt2',
        # PREFIX_MAJOR_IDX + '.rev.2.bt2'
    params:
        os.path.join(DIR, 'major/wg_h37maj/indexes')
    shell:
        'bowtie2-build --threads {THREADS} {input} {params}'
 
rule build_grc_index:
    input:
        genome = GENOME
    output:
        expand(
            os.path.join(DIR, 'grch37/wg.{idx}.bt2'),
            idx = IDX_ITEMS)
        # PREFIX_MAJOR_IDX + '.1.bt2',
        # PREFIX_MAJOR_IDX + '.2.bt2',
        # PREFIX_MAJOR_IDX + '.3.bt2',
        # PREFIX_MAJOR_IDX + '.4.bt2',
        # PREFIX_MAJOR_IDX + '.rev.1.bt2',
        # PREFIX_MAJOR_IDX + '.rev.2.bt2'
    params:
        os.path.join(DIR, 'grch37/wg')
    shell:
        'bowtie2-build --threads {THREADS} {input.genome} {params}'

''' Reference flow: first pass '''
rule align_to_ref:
    input:
        reads1 = READS1,
        idx = expand(
            os.path.join(DIR, 'grch37/wg.{idx}.bt2'),
            idx = IDX_ITEMS)
    params:
        index = os.path.join(DIR, 'grch37/indexes/wg')
    output:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-GRCh37.sam')
    shell:
        'bowtie2 --threads {THREADS} -x {params.index} -U {input.reads1} -S {output.sam}'

rule align_to_major:
    input:
        reads1 = READS1,
        idx = expand(
            os.path.join(DIR, 'major/wg_h37maj.{idx}.bt2'),
            idx = IDX_ITEMS)
    params:
        index = os.path.join(DIR, 'major/indexes/wg_h37maj')
    output:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam')
    shell:
        'bowtie2 --threads {THREADS} -x {params.index} -U {input.reads1} -S {output.sam}'
# 
# rule select_reads_using_mapq:
# 
# ''' Reference flow: prepare pop genome '''
# 
# ''' Reference flow: second pass '''
# rule align_to_pop_genome:

rule refflow_separate_fistpass_results:
    input:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam')
    output:
        highq = os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '.sam'),
        lowq = os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.sam'),
        lowq_reads = os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq')
    shell:
        'awk -v var="{ALN_MAPQ_THRSD}" \
        \'{{ if ($5 >= var || $1 ~ /^@/) {{ print }} }}\' {input.sam} > \
        {output.highq};'
        'awk -v var={ALN_MAPQ_THRSD} \
        \'{{ if ($5 < var || $1 ~ /^@/) {{ print }} }}\' {input.sam} > \
        {output.lowq};'
        'samtools fastq {output.lowq} > {output.lowq_reads}'

rule aggregate_major_vcf:
    input:
        vcf = expand(PREFIX_MAJOR + '.vcf', CHROM = CHROM)
    output:
        vcf_major = os.path.join(DIR, 'major/wg_h37maj.vcf')
    run:
        for i, chrom in enumerate(CHROM):
            if i == 0:
                vcf = input.vcf[0]
                shell('cp {vcf} {output.vcf_major};')
            else:
                vcf = input.vcf[i]
                shell('{BCFTOOLS} view -H {vcf} >> {output.vcf_major}')

rule aggregate_vcf_and_get_het:
    input:
        vcf = expand(os.path.join(DIR, '{CHROM}_filtered.vcf'), CHROM = CHROM)
    output:
        vcf = os.path.join(DIR, 'wg_filtered.vcf')
    run:
        for i, chrom in enumerate(CHROM):
            if i == 0:
                vcf = input.vcf[0]
                shell('cp {vcf} {output.vcf};')
            else:
                vcf = input.vcf[i]
                shell('{BCFTOOLS} view -H {vcf} >> {output.vcf}')

rule get_het:
    input:
        vcf = os.path.join(DIR, 'wg_filtered.vcf')
    output:
        het = os.path.join(DIR, 'wg_{INDIV}_het.vcf')
    shell:
        '{BCFTOOLS} view -s {INDIV} {input.vcf} | {BCFTOOLS} view -i "AC>0" -v snps -g het -m2 -M2 > {output.het}'

rule get_het_with_indel:
    input:
        vcf = os.path.join(DIR, 'wg_filtered.vcf')
    output:
        het = os.path.join(DIR, 'wg_{INDIV}_het_withindel.vcf')
    shell:
        '{BCFTOOLS} view -s {INDIV} {input.vcf} | {BCFTOOLS} view -i "AC>0" -g het -m2 -M2 > {output.het}'


rule get_het_with_indel_processed:
    input:
        het = os.path.join(DIR, 'wg_{INDIV}_het_withindel.vcf')
    output:
        het = os.path.join(DIR, 'wg_{INDIV}_het_no_overlaps.vcf')
    shell:
        'cat {input.het} | python {DIR_SCRIPTS}/remove_het_overlapping_indel.py > {output.het}'

rule liftover_serialize_major:
    input:
        vcf_major = os.path.join(DIR, 'major/wg_h37maj.vcf')
    output:
        lft = os.path.join(DIR_MAJOR, 'wg-h37maj.lft')
    params:
        os.path.join(DIR_MAJOR, 'wg-h37maj')
    shell:
        'module load gcc/5.5.0;'
        '{LIFTOVER} serialize -v {input.vcf_major} -p {params}'

rule liftover_lift_major:
    input:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam'),
        lft = os.path.join(DIR_MAJOR, 'wg-h37maj.lft')
    output:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover.sam')
    params:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover')
    shell:
        'module load gcc/5.5.0;'
        '{LIFTOVER} lift -a {input.sam} -l {input.lft} -p {params}'

rule liftover_lift_major_highq:
    input:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10.sam'),
        lft = os.path.join(DIR_MAJOR, 'wg-h37maj.lft')
    output:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10-liftover.sam')
    params:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10-liftover')
    shell:
        'module load gcc/5.5.0;'
        '{LIFTOVER} lift -a {input.sam} -l {input.lft} -p {params}'

# rule liftover_lift_major:
#     input:
#         sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam'),
#         sam_hq = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10.sam'),
#         lft = os.path.join(DIR_FIRST_PASS, 'major.lft')
#     output:
#         all = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover.sam'),
#         hq = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10-liftover.sam')
#     params:
#         all = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover'),
#         hq = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10-liftover')
#     shell:
#         'module load gcc/5.5.0;'
#         '{LIFTOVER} lift -a {input.sam} -l {input.lft} -p {params.all};'
#         '{LIFTOVER} lift -a {input.sam_hq} -l {input.lft} -p {params.hq}'

# rule liftover_firstpass:
#     input:
#         highq = os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '.sam')
#     output:
#         highq = os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '-liftover.sam')
        

## TODO replace with "checkpoint"
# rule refflow_split_secondpass_reads:
#     input:
#         os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq')
#     output:
#         dynamic(os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq_{fq_id}'))
#     shell:
#         'split -d -l {MAX_NUM_READS_FOR_MERGING} {input} {input}_'

# checkpoint refflow_split_secondpass_reads:
#     input:
#         os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq')
#     output:
#         os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq_{fq_id}')
#     shell:
#         'split -d -l {MAX_NUM_READS_FOR_MERGING} {input} {input}_'

rule refflow_align_secondpass:
    input:
        reads = os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq'),
        idx1 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.1.bt2'),
        idx2 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.2.bt2'),
        idx3 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.3.bt2'),
        idx4 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.4.bt2'),
        idx5 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.rev.1.bt2'),
        idx6 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.rev.2.bt2')
    params:
        index = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX)
    output:
        sam = PREFIX_SECOND_PASS + '.sam'
    shell:
        'bowtie2 --reorder --threads {THREADS} -x {params.index} -U {input.reads} -S {output.sam};'

rule refflow_merge_secondpass:
    input:
        sam = expand(
            PREFIX_SECOND_PASS + '.sam',
            INDIV = INDIV, GROUP = GROUP)
    output:
        path = os.path.join(DIR_SECOND_PASS, 'wg-h37maj-{}-{}.paths'.format(ALN_MAPQ_THRSD, POP_DIRNAME)),
        id = os.path.join(DIR_SECOND_PASS, 'wg-h37maj-{}-{}.ids'.format(ALN_MAPQ_THRSD, POP_DIRNAME)),
        merge_paths = os.path.join(DIR_SECOND_PASS, 'wg-h37maj-{}-{}.merge_paths'.format(ALN_MAPQ_THRSD, POP_DIRNAME))
    params:
        prefix = os.path.join(DIR_SECOND_PASS, '2ndpass')
    run:
        # indiv = wildcards.INDIV
        dir_2p = os.path.join(DIR, 'experiments/' + wildcards.INDIV + '/' + POP_DIRNAME)
        maj_lowq = os.path.join(DIR, 'experiments/' + wildcards.INDIV + '/wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.sam')

        shell('echo {maj_lowq} > {output.path};')
        shell('echo "h37maj" > {output.id};')
        for g in GROUP:
            fn = os.path.join(dir_2p, 'wg-h37maj-{}-{}-{}.sam'.format(ALN_MAPQ_THRSD, g, POP_DIRNAME))
            shell('ls {fn} >> {output.path};')
            shell('echo {g} >> {output.id}')
        shell('{PYTHON} {DIR_SCRIPTS}/merge_incremental.py -ns {output.path} \
            -ids {output.id} -rs {RAND_SEED} -p {params.prefix} \
            -l {output.merge_paths} -id {g};')

rule check_secondpass:
    input:
        merge_paths = expand(
            os.path.join(DIR_SECOND_PASS, 'wg-h37maj-{}-{}.merge_paths'.format(ALN_MAPQ_THRSD, POP_DIRNAME)),
            INDIV = INDIV)
    output:
        touch(temp(os.path.join(DIR, 'secondpass.done')))

'''
Rules for building population genomes
'''
rule prepare_pop_indiv:
    output:
        expand(
            os.path.join(DIR, '1KG_indivs/sample_superpop_{GROUP}.txt'),
            GROUP = GROUP
        )
    params:
        prefix = os.path.join(DIR, '1KG_indivs/sample')
    shell:
        '{PYTHON} {DIR_SCRIPTS}/list_indiv_from_pop.py '
        '-p {FAMILY} -sp {SPOP} -op {params.prefix}'

rule build_pop_vcf:
    input:
        vcf = PREFIX_VCF_F + '.vcf',
        indiv_group = os.path.join(
            DIR,
            '1KG_indivs/sample_superpop_{GROUP}.txt'
        )
    output:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            '{CHROM}_superpop_{GROUP}.vcf.gz')
    shell:
        '{BCFTOOLS} view --threads {THREADS} -S {input.indiv_group} '
        '--force-samples {input.vcf} -V mnps,other -m2 -M2 | '
        'bgzip -@ {THREADS} > {output.vcf_gz}'

rule get_pop_sample:
    input:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            '{CHROM}_superpop_{GROUP}.vcf.gz')
    output:
        vcf_header = os.path.join(DIR_POP_GENOME,
            '{CHROM}_superpop_{GROUP}.samples')
    shell:
        '{BCFTOOLS} view -h {input.vcf_gz} | tail -1 '
        '> {output.vcf_header}'

rule filter_pop_vcf:
    input:
        vcf_gz = os.path.join(DIR_POP_GENOME,
            '{CHROM}_superpop_{GROUP}.vcf.gz'),
        vcf_header = os.path.join(DIR_POP_GENOME,
            '{CHROM}_superpop_{GROUP}.samples')
    output:
        vcf = os.path.join(
            DIR_POP_GENOME,
            '{CHROM}_superpop_{GROUP}_t' + str(POP_THRSD) + '.vcf'
        )
    run:
        fn = list({input.vcf_header})[0]
        with open(fn, 'r') as f:
            for line in f:
                n = len(line.split()) - 9
                thrsd = int(n * 2 * float(POP_THRSD))
                filt = 'AC > {}'.format(thrsd)
                break
        shell('{BCFTOOLS} view --threads {THREADS} -i "{filt}" \
            -v snps,indels {input.vcf_gz} > {output.vcf};')

rule build_pop_genome:
    input:
        vcf = os.path.join(
            DIR_POP_GENOME,
            '{CHROM}_superpop_{GROUP}_t' + str(POP_THRSD) + '.vcf'
        )
    output:
        os.path.join(
            DIR_POP_GENOME_BLOCK,
            '{CHROM}_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.fa'
        ),
        os.path.join(
            DIR_POP_GENOME_BLOCK,
            '{CHROM}_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.var'
        )
    params:
        prefix = os.path.join(
            DIR_POP_GENOME_BLOCK,
            '{CHROM}_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD)
        )
    run:
        if POP_STOCHASTIC == 1 and POP_USE_LD == 1:
            shell('{PYTHON} {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {wildcards.CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels --stochastic -rs {RAND_SEED} \
                --block-size {POP_BLOCK_SIZE} --ld')
        elif POP_STOCHASTIC == 1:
            shell('{PYTHON} {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {wildcards.CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels --stochastic -rs {RAND_SEED} \
                --block-size {POP_BLOCK_SIZE}')
        else:
            shell('{PYTHON} {DIR_SCRIPTS}/update_genome.py \
                --ref {GENOME} --chrom {wildcards.CHROM} --vcf {input.vcf} \
                --out-prefix {params.prefix} \
                --include-indels')

rule merge_pop_genome:
    input:
        expand(os.path.join(DIR_POP_GENOME_BLOCK,
            '{CHROM}_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.fa'), CHROM = CHROM, GROUP = GROUP)
    output:
        os.path.join(DIR_POP_GENOME_BLOCK,
            'wg_superpop_{GROUP}_thrds' + str(POP_THRSD) +
            '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
            '_ld' + str(POP_USE_LD) + '.fa')
    run:
        list_fn = []
        for fn in input:
            print (fn)
            print (wildcards.GROUP)
            if fn.count(wildcards.GROUP) > 0:
                list_fn.append(fn)
        shell('cat {list_fn} >> {output}')

rule build_pop_genome_index:
    input:
        genome = os.path.join(DIR_POP_GENOME_BLOCK, WG_POP_GENOME_SUFFIX + '.sam')
#             'wg_superpop_{GROUP}_thrds' + str(POP_THRSD) +
#             '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + 
#             '_ld' + str(POP_USE_LD) + '.fa')
    output:
        os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.1.bt2'),
        os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.2.bt2'),
        os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.3.bt2'),
        os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.4.bt2'),
        os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.rev.1.bt2'),
        os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.rev.2.bt2')
    params:
        os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX)
    shell:
        'bowtie2-build --threads {THREADS} {input.genome} {params};'

rule check_pop_genome:
    input:
        expand(
            DIR_POP_GENOME_BLOCK_IDX + WG_POP_GENOME_SUFFIX + '.{IDX_ITEMS}.bt2',
            GROUP = GROUP, IDX_ITEMS = IDX_ITEMS
        )
    output:
        touch(temp(os.path.join(DIR, 'check_popgenome_{GROUP}.done')))
