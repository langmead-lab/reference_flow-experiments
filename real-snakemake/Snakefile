#/home-1/cnaechy1@jhu.edu/miniconda3/bin/python3.7
import os
import pandas as pd

configfile: "config.yaml"

''' Load from config '''
CHROM = config['CHROM']
INDIV = config['INDIV']
READS1 = config['READS1']
GROUP = config['GROUP']
# NUM_SIM_READS = config['NUM_SIM_READS']
ALN_MAPQ_THRSD = config['ALN_MAPQ_THRSD']
POP_THRSD = config['POP_THRSD']
POP_STOCHASTIC = config['POP_STOCHASTIC']
POP_BLOCK_SIZE = config['POP_BLOCK_SIZE']
POP_USE_LD = config['POP_USE_LD']
BIAS_MIN_READ_COUNT = config['BIAS_MIN_READ_COUNT']
BIAS_TAIL_THRDS = config['BIAS_TAIL_THRDS']

DIR = config['DIR']
GENOME = config['GENOME']
# VCF = config['VCF']
DIR_VCF = config['DIR_VCF']

FAMILY = config['FAMILY']
SPOP = config['SPOP']
BCFTOOLS = config['BCFTOOLS']
SAMTOOLS = config['SAMTOOLS']
MASON2 = config['MASON2']
LIFTOVER = config['LIFTOVER']
PYTHON = config['PYTHON']
DIR_SCRIPTS = config['DIR_SCRIPTS']
THREADS = config['THREADS']
RAND_SEED = config['RAND_SEED']
MAX_NUM_READS_FOR_MERGING = config['MAX_NUM_READS_FOR_MERGING']
''''''

PREFIX_VCF_F = os.path.join(DIR, '{CHROM}_filtered')
PREFIX_MAJOR_F = os.path.join(DIR, 'major/{CHROM}_filtered_major')
PREFIX_MAJOR = os.path.join(DIR, 'major/{CHROM}_h37maj')
DIR_MAJOR = os.path.join(DIR, 'major')

DIR_FIRST_PASS = os.path.join(DIR, 'experiments/' + INDIV + '/')

DIR_POP_GENOME = os.path.join(DIR, 'pop_genome/')
POP_DIRNAME = 'thrds{0}_S{1}_b{2}_ld{3}'.format(POP_THRSD, POP_STOCHASTIC, POP_BLOCK_SIZE, POP_USE_LD)
# POP_DIRNAME = 'thrds{0}_S{1}_block{2}_ld{3}'.format(POP_THRSD, POP_STOCHASTIC, POP_BLOCK_SIZE, POP_USE_LD)
POP_GENOME_SUFFIX = \
    'c{CHROM}_superpop_{GROUP}_thrds' + str(POP_THRSD) + \
    '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + \
    '_ld' + str(POP_USE_LD)
WG_POP_GENOME_SUFFIX = \
    'wg_superpop_{GROUP}_thrds' + str(POP_THRSD) + \
    '_S' + str(POP_STOCHASTIC) + '_b' + str(POP_BLOCK_SIZE) + \
    '_ld' + str(POP_USE_LD)
DIR_POP_GENOME_BLOCK = os.path.join(DIR_POP_GENOME, POP_DIRNAME + '/')
DIR_POP_GENOME_BLOCK_IDX = os.path.join(DIR_POP_GENOME_BLOCK, 'indexes/')

DIR_PER = os.path.join(DIR, 'personalized/{INDIV}/')

DIR_FIRST_PASS = os.path.join(DIR, 'experiments/{INDIV}/')
DIR_SECOND_PASS = os.path.join(DIR, 'experiments/{INDIV}/' + POP_DIRNAME)
PREFIX_SECOND_PASS = os.path.join(DIR_SECOND_PASS, 'wg-h37maj-' + ALN_MAPQ_THRSD + '-{GROUP}-' + POP_DIRNAME)

DIR_RESULTS_BIAS = os.path.join(DIR, 'results/bias')

IDX_ITEMS = ['1', '2', '3', '4', 'rev.1', 'rev.2']

include: '../snakemake/shared/functions.Snakefile'

#: Prepare pop genome and indexes
#:      check: 'prepare_pop_genome.done'
include: 'shared/prepare_pop_genome.Snakefile'

#: Prepare grch37 and major genome and indexes
#:      check: 'prepare_standard_genome.done'
include: 'shared/prepare_standard_genome.Snakefile'

#: Calculate allelic bias
#:      check: 'allelic_bias.done'
include: 'shared/calc_bias.Snakefile'

rule all:
    input:
        filtered_vcf = expand(PREFIX_VCF_F + '.vcf', CHROM = CHROM),
        #: Building genomes
        pop_genome = os.path.join(DIR, 'prepare_pop_genome.done'),
        standard_genome = os.path.join(DIR, 'prepare_standard_genome.done'),
        major_sam = expand(os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam'), INDIV = INDIV),
        grch37_sam = expand(os.path.join(DIR_FIRST_PASS, 'wg-GRCh37-sorted.sam'), INDIV = INDIV),
        secondpass = os.path.join(DIR, 'secondpass.done'),
        # secondpass_tmptmp = dynamic(os.path.join(DIR, 'secondpass_useless.done')),
        # secondpass_tmp = dynamic(os.path.join(DIR, 'secondpass_useless.done_{fq_id}'))
        het_no_overlaps = expand(os.path.join(DIR, 'wg_{INDIV}_het_no_overlaps.vcf'), INDIV = INDIV),
        lifted_major = expand(os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover.sam'), INDIV = INDIV),
        sorting = os.path.join(DIR, 'sorting.done'),
        allelic_bias = os.path.join(DIR, 'allelic_bias.done'),
        # tmp
        pop_aggreate = expand(os.path.join(DIR_POP_GENOME_BLOCK, 'wg_superpop_{GROUP}_' + POP_DIRNAME + '.vcf'), GROUP = GROUP)

rule filter_vcf:
    input:
        vcf = os.path.join(DIR_VCF, '{CHROM}.vcf.gz')
    output:
        vcf = PREFIX_VCF_F + '.vcf'
    shell:
        '{BCFTOOLS} view -V mnps,other {input.vcf} > {output.vcf}'

rule build_major:
    input:
        genome = GENOME,
        vcf = PREFIX_VCF_F + '.vcf'
    output:
        vcf_major = PREFIX_MAJOR_F + '.vcf',
        vcf_major_gz = PREFIX_MAJOR_F + '.vcf.gz',
        vcf_major_gz_csi = PREFIX_MAJOR_F + '.vcf.gz.csi',
        out_genome = PREFIX_MAJOR + '.fa',
        out_var = PREFIX_MAJOR + '.var',
        out_vcf = PREFIX_MAJOR + '.vcf'
    params:
        chrom_genome = os.path.join(DIR, '{CHROM}.fa'),
        out_prefix = os.path.join(DIR, 'major/{CHROM}_h37maj')
    shell:
        '{BCFTOOLS} view -O z -q 0.5 {input.vcf} -e \'AF = 0.5\' -v snps,indels -m2 -M2 > '
        '{output.vcf_major_gz};'
        '{BCFTOOLS} index {output.vcf_major_gz};'
        'bgzip -cd {output.vcf_major_gz} > {output.vcf_major};'
        '{SAMTOOLS} faidx {input.genome} {wildcards.CHROM} > {params.chrom_genome};'
        '{PYTHON} {DIR_SCRIPTS}/update_genome.py '
        '    --ref {params.chrom_genome} --vcf {output.vcf_major} '
        '    --chrom {wildcards.CHROM} --out-prefix {params.out_prefix} '
        '    --include-indels'


''' Reference flow: first pass '''
rule align_to_ref:
    input:
        reads1 = READS1,
        idx = expand(
            os.path.join(DIR, 'grch37/wg.{idx}.bt2'),
            idx = IDX_ITEMS)
    params:
        index = os.path.join(DIR, 'grch37/indexes/wg')
    output:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-GRCh37.sam')
    threads: THREADS
    shell:
        'bowtie2 --threads {THREADS} -x {params.index} -U {input.reads1} -S {output.sam}'

rule align_to_major:
    input:
        reads1 = READS1,
        idx = expand(
            os.path.join(DIR, 'major/wg_h37maj.{idx}.bt2'),
            idx = IDX_ITEMS)
    params:
        index = os.path.join(DIR, 'major/indexes/wg_h37maj')
    output:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam')
    threads: THREADS
    shell:
        'bowtie2 --threads {THREADS} -x {params.index} -U {input.reads1} -S {output.sam}'
# 
# rule select_reads_using_mapq:
# 
# ''' Reference flow: prepare pop genome '''
# 
# ''' Reference flow: second pass '''
# rule align_to_pop_genome:

rule refflow_separate_fistpass_results:
    input:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam')
    output:
        highq = os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '.sam'),
        lowq = os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.sam'),
        lowq_reads = os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq')
    shell:
        'awk -v var="{ALN_MAPQ_THRSD}" \
        \'{{ if ($5 >= var || $1 ~ /^@/) {{ print }} }}\' {input.sam} > \
        {output.highq};'
        'awk -v var={ALN_MAPQ_THRSD} \
        \'{{ if ($5 < var || $1 ~ /^@/) {{ print }} }}\' {input.sam} > \
        {output.lowq};'
        'samtools fastq {output.lowq} > {output.lowq_reads}'

rule aggregate_major_vcf:
    input:
        vcf = expand(PREFIX_MAJOR + '.vcf', CHROM = CHROM)
    output:
        vcf_major = os.path.join(DIR, 'major/wg_h37maj.vcf')
    run:
        for i, chrom in enumerate(CHROM):
            if i == 0:
                vcf = input.vcf[0]
                shell('cp {vcf} {output.vcf_major};')
            else:
                vcf = input.vcf[i]
                shell('{BCFTOOLS} view -H {vcf} >> {output.vcf_major}')

rule aggregate_vcf:
    input:
        vcf = expand(os.path.join(DIR, '{CHROM}_filtered.vcf'), CHROM = CHROM)
    output:
        vcf = os.path.join(DIR, 'wg_filtered.vcf')
    run:
        for i, chrom in enumerate(CHROM):
            if i == 0:
                vcf = input.vcf[0]
                shell('cp {vcf} {output.vcf};')
            else:
                vcf = input.vcf[i]
                shell('{BCFTOOLS} view -H {vcf} >> {output.vcf}')

rule aggregate_pop_genome_vcf:
    input:
        vcf = expand(os.path.join(DIR_POP_GENOME_BLOCK,
            POP_GENOME_SUFFIX + '.vcf'),
            CHROM = CHROM, GROUP = GROUP)
    output:
        vcf = os.path.join(DIR_POP_GENOME_BLOCK,
            WG_POP_GENOME_SUFFIX + '.vcf')
    run:
        for i, chrom in enumerate(CHROM):
            if i == 0:
                vcf = input.vcf[0]
                shell('cp {vcf} {output.vcf};')
            else:
                vcf = input.vcf[i]
                shell('{BCFTOOLS} view -H {vcf} >> {output.vcf}')

rule get_het:
    input:
        vcf = os.path.join(DIR, 'wg_filtered.vcf')
    output:
        het = os.path.join(DIR, 'wg_{INDIV}_het.vcf')
    shell:
        '{BCFTOOLS} view -s {INDIV} {input.vcf} | {BCFTOOLS} view -i "AC>0" -v snps -g het -m2 -M2 > {output.het}'

rule get_het_with_indel:
    input:
        vcf = os.path.join(DIR, 'wg_filtered.vcf')
    output:
        het = os.path.join(DIR, 'wg_{INDIV}_het_withindel.vcf')
    shell:
        '{BCFTOOLS} view -s {INDIV} {input.vcf} | {BCFTOOLS} view -i "AC>0" -g het -m2 -M2 > {output.het}'


rule get_het_with_indel_processed:
    input:
        het = os.path.join(DIR, 'wg_{INDIV}_het_withindel.vcf')
    output:
        het = os.path.join(DIR, 'wg_{INDIV}_het_no_overlaps.vcf')
    shell:
        'cat {input.het} | python {DIR_SCRIPTS}/remove_het_overlapping_indel.py > {output.het}'

rule liftover_serialize_major:
    input:
        vcf_major = os.path.join(DIR, 'major/wg_h37maj.vcf')
    output:
        lft = os.path.join(DIR_MAJOR, 'wg-h37maj.lft')
    params:
        os.path.join(DIR_MAJOR, 'wg-h37maj')
    shell:
        'module load gcc/5.5.0;'
        '{LIFTOVER} serialize -v {input.vcf_major} -p {params}'

rule liftover_lift_major:
    input:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam'),
        lft = os.path.join(DIR_MAJOR, 'wg-h37maj.lft')
    output:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover.sam')
    params:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover')
    shell:
        'module load gcc/5.5.0;'
        '{LIFTOVER} lift -a {input.sam} -l {input.lft} -p {params}'

rule liftover_lift_major_highq:
    input:
        sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10.sam'),
        lft = os.path.join(DIR_MAJOR, 'wg-h37maj.lft')
    output:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10-liftover.sam')
    params:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10-liftover')
    shell:
        'module load gcc/5.5.0;'
        '{LIFTOVER} lift -a {input.sam} -l {input.lft} -p {params}'

''' Sort using samtools '''
rule sort_lifted_major:
    input:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover.sam')
    output:
        os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover-sorted.sam')
    shell:
        'samtools sort -@ {THREADS} -o {output} {input}'

rule sort_grc:
    input:
        os.path.join(DIR_FIRST_PASS, 'wg-GRCh37.sam')
    output:
        os.path.join(DIR_FIRST_PASS, 'wg-GRCh37-sorted.sam')
    shell:
        'samtools sort -@ {THREADS} -o {output} {input}'

rule sort_lifted_refflow_firstpass:
    input:
        os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqgeq{}-liftover.sam'.format(ALN_MAPQ_THRSD))
    output:
        os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqgeq{}-liftover-sorted.sam'.format(ALN_MAPQ_THRSD))
    threads: THREADS
    run:
        shell('samtools sort -@ {THREADS} -o {output} {input};')

rule check_sort:
    input:
        expand(os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-liftover-sorted.sam'), INDIV = INDIV),
        expand(os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqgeq{}-liftover-sorted.sam'.format(ALN_MAPQ_THRSD)),
            INDIV = INDIV)
    output:
        touch(temp(os.path.join(DIR, 'sorting.done')))

# rule liftover_lift_major:
#     input:
#         sam = os.path.join(DIR_FIRST_PASS, 'wg-h37maj.sam'),
#         sam_hq = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10.sam'),
#         lft = os.path.join(DIR_FIRST_PASS, 'major.lft')
#     output:
#         all = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover.sam'),
#         hq = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10-liftover.sam')
#     params:
#         all = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-liftover'),
#         hq = os.path.join(DIR_FIRST_PASS, 'wg-h37maj-mapqgeq10-liftover')
#     shell:
#         'module load gcc/5.5.0;'
#         '{LIFTOVER} lift -a {input.sam} -l {input.lft} -p {params.all};'
#         '{LIFTOVER} lift -a {input.sam_hq} -l {input.lft} -p {params.hq}'

# rule liftover_firstpass:
#     input:
#         highq = os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '.sam')
#     output:
#         highq = os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqgeq' + ALN_MAPQ_THRSD + '-liftover.sam')
        

## TODO replace with "checkpoint"
# rule refflow_split_secondpass_reads:
#     input:
#         os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq')
#     output:
#         dynamic(os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq_{fq_id}'))
#     shell:
#         'split -d -l {MAX_NUM_READS_FOR_MERGING} {input} {input}_'

# checkpoint refflow_split_secondpass_reads:
#     input:
#         os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq')
#     output:
#         os.path.join(DIR_FIRST_PASS,
#             'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq_{fq_id}')
#     shell:
#         'split -d -l {MAX_NUM_READS_FOR_MERGING} {input} {input}_'

rule refflow_align_secondpass:
    input:
        reads = os.path.join(DIR_FIRST_PASS,
            'wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.fq'),
        idx1 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.1.bt2'),
        idx2 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.2.bt2'),
        idx3 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.3.bt2'),
        idx4 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.4.bt2'),
        idx5 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.rev.1.bt2'),
        idx6 = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX + '.rev.2.bt2')
    params:
        index = os.path.join(DIR_POP_GENOME_BLOCK_IDX, WG_POP_GENOME_SUFFIX)
    output:
        sam = PREFIX_SECOND_PASS + '.sam'
    threads: THREADS
    shell:
        'bowtie2 --reorder --threads {THREADS} -x {params.index} -U {input.reads} -S {output.sam};'

rule refflow_merge_secondpass:
    input:
        sam = expand(
            PREFIX_SECOND_PASS + '.sam',
            INDIV = INDIV, GROUP = GROUP)
    output:
        path = os.path.join(DIR_SECOND_PASS, 'wg-h37maj-{}-{}.paths'.format(ALN_MAPQ_THRSD, POP_DIRNAME)),
        id = os.path.join(DIR_SECOND_PASS, 'wg-h37maj-{}-{}.ids'.format(ALN_MAPQ_THRSD, POP_DIRNAME)),
        merge_paths = os.path.join(DIR_SECOND_PASS, 'wg-h37maj-{}-{}.merge_paths'.format(ALN_MAPQ_THRSD, POP_DIRNAME))
    params:
        prefix = os.path.join(DIR_SECOND_PASS, '2ndpass')
    run:
        # indiv = wildcards.INDIV
        dir_2p = os.path.join(DIR, 'experiments/' + wildcards.INDIV + '/' + POP_DIRNAME)
        maj_lowq = os.path.join(DIR, 'experiments/' + wildcards.INDIV + '/wg-h37maj-mapqlt' + ALN_MAPQ_THRSD + '.sam')

        shell('echo {maj_lowq} > {output.path};')
        shell('echo "h37maj" > {output.id};')
        for g in GROUP:
            fn = os.path.join(dir_2p, 'wg-h37maj-{}-{}-{}.sam'.format(ALN_MAPQ_THRSD, g, POP_DIRNAME))
            shell('ls {fn} >> {output.path};')
            shell('echo {g} >> {output.id};')
        shell('{PYTHON} {DIR_SCRIPTS}/merge_incremental.py -ns {output.path} \
            -ids {output.id} -rs {RAND_SEED} -p {params.prefix} \
            -l {output.merge_paths};')

rule check_secondpass:
    input:
        merge_paths = expand(
            os.path.join(DIR_SECOND_PASS, 'wg-h37maj-{}-{}.merge_paths'.format(ALN_MAPQ_THRSD, POP_DIRNAME)),
            INDIV = INDIV)
    output:
        touch(temp(os.path.join(DIR, 'secondpass.done')))

